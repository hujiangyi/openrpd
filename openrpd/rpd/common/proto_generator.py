#!/usr/bin/python
#
# Copyright (c) 2016 Cisco and/or its affiliates, and
#                    Cable Television Laboratories, Inc. ("CableLabs")
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from sys import argv
from rpd.rcp.gcp.gcp_lib.gcp_data_description import EnumConstraint, BOOL_CONSTR

PROTOFILE_HEADER = """/*
 * Copyright (c) 2016 Cisco and/or its affiliates, and
 *                    Cable Television Laboratories, Inc. ("CableLabs")
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 /*
  * File has been generated by proto_generator.py
  */

"""


class ProtoGenerator(object):
    TYPE_PREFIX = 't_'

    # Protocol buffer language does not know (u)int16 or (u)int8,
    # so it's stored in 32 bits alternatives. All special types
    # (ip address, MAC address,..) are stored as a string, to be readable
    # in DB dump file
    types = {
        "!b": "int32",  # signed char
        "!B": "uint32",  # unsigned char
        "!h": "int32",  # short
        "!H": "uint32",  # unsigned short
        "!i": "int32",  # int
        "!I": "uint32",  # unsigned int
        "!l": "int32",  # long
        "!L": "uint32",  # unsigned long
        "!q": "int64",  # long long
        "!Q": "uint64",  # unsigned long long
        "var": "string",
        "bytes": "bytes"
    }
    OUT_FILE = './cfg.proto'

    # for general purpose gcp tlv combined into cfg tlv
    gp_selector_tlv = {
        12: "RfChannelSelector",
        13: "RfPortSelector",
    }

    def __init__(self, base, messageName="config", indent=4):
        self.proto_string = PROTOFILE_HEADER
        self.proto_string += 'syntax = "proto2";\n\n'
        self.split_proto_string = ""
        self.split_proto_filep = ""
        self.indent_step = indent
        self.base = base
        self.messageName = messageName

    def _walk_tree(self, indent=0, parent=None, seperate=False, lvl=0):
        """Walk TLV definitions recursively and process each of them.

        :param indent: number of spaces used for indentation in .proto file.
        :type indent: int
        :param parent: desciption (definition) of TLV (with nested TLVs)
        :type parent: TLVDesc
        :param seperate: split *.proto to seperate files contained in cfg.proto
        :param lvl: to identify the messages level contained in cfg.proto
        :return: generated string
        :rtype: string

        """
        if parent is None:
            child_dict = self.base.child_dict_by_id
        else:
            child_dict = parent.child_dict_by_id

        lvl += 1
        children = ""
        for tlv in child_dict.values():
            children += self._walk_tree(indent + self.indent_step, tlv,
                                        seperate, lvl)

        format_str = self._to_proto_string(parent, indent, children,
                                           seperate, lvl)
        return format_str

    def generate(self, out_file=OUT_FILE, sep=True):
        """Generate definitions of Google Protocol Buffer objects and save
        these definitions to .proto file specified as argument for this script.
        Inputs (list of TLV definitions) are imported in "main" function.

        :param out_file: path to file, where generated output will be stored
        :return:

        """
        if sep:
            self.split_proto_filep = '/'.join(out_file.split("/")[:-1])
        self.split_proto_filep += "/"

        proto_string = self._walk_tree(seperate=sep)
        self.proto_string += proto_string

        with open(out_file, 'w') as proto_file:
            proto_file.write(self.proto_string)

    def _to_proto_string(self, tlv, indent, children, split, lvl):
        ind = ' ' * indent
        if tlv is None:
            # Parent TLV
            return "{0}message {1} {{\n{2}{0}}}" \
                .format(ind, self.messageName, children)
        val_type = ProtoGenerator.types[tlv.format_str] if \
            tlv.format_str in ProtoGenerator.types else "string"

        enums = ""
        if tlv.constraint is BOOL_CONSTR:
            val_type = "bool"
        elif isinstance(tlv.constraint, EnumConstraint):
            val_str = ""
            for val, name in tlv.constraint.allowed_values.iteritems():

                # One line with with value from enum: E_name = NUM;
                val_str += "{0}{1} = {2};\n" \
                    .format((indent + self.indent_step) * ' ', name.upper(),
                            val)
            enums += "\n{0}enum {3}{1} {{\n{2}{0}}}\n\n" \
                .format(ind, tlv.name, val_str, self.TYPE_PREFIX)
            val_type = self.TYPE_PREFIX + tlv.name

        if not isinstance(tlv, TLVDesc):
            raise AttributeError("Invalid TLV")

        rule = "optional"
        if tlv.is_tlv_key():
            rule = "optional"
        elif tlv.is_tlv_row():
            # If any child is key, then class must be marked as repeated
            if any(x.is_tlv_key()
                   for x in tlv.get_nested_descriptions().values()):
                rule = "repeated"
        elif tlv.is_tlv_repeated_fields():
            rule = "repeated"
        if tlv.is_tlv_row_key():
            rule = "repeated"
            print "###", tlv.name, val_type
            val_type = self.TYPE_PREFIX + tlv.name

        if tlv.id in ProtoGenerator.gp_selector_tlv and \
                ProtoGenerator.gp_selector_tlv[tlv.id] == tlv.name:
            rule = "required"

        if not tlv.is_tlv_row():
            return "{1}{0}{2} {3} {4} = {5};\n" \
                .format(ind, enums, rule, val_type, tlv.name, tlv.id + 1)
        else:
            split_str = "\n{0}message {5}{1} {{\n{2}{0}}}\n"\
                .format(ind, tlv.name, children, tlv.id + 1, rule,
                        self.TYPE_PREFIX)
            ret_str = "\n{0}{4} {5}{1} {1} = {3};\n"\
                .format(ind, tlv.name, children, tlv.id + 1, rule,
                        self.TYPE_PREFIX)
            if split and lvl == 2:
                self.proto_string += 'import "%s.proto";\n\n' % tlv.name
                with open(self.split_proto_filep + tlv.name + ".proto", 'w') as p_file:
                    p_file.write(PROTOFILE_HEADER + 'syntax = "proto2";\n\n' +
                                 self.split_proto_string + split_str)
                return ret_str
            else:
                return split_str + ret_str


def print_help(cl_args):
    """Print help string with all possible input arguments.

    :param cl_args: argument list
    :return:

    """
    print "Parameter expected."
    print "Usage: {} [--test] <output-proto-name>\n".format(cl_args[0])
    print "Usage: {} [--gcp] <output-proto-name>\n".format(cl_args[0])
    print "Usage: {} [--ucd] <output-proto-name>\n".format(cl_args[0])
    print "Usage: {} [--ocd] <output-proto-name>\n".format(cl_args[0])


if __name__ == '__main__':
    next_arg = 1
    messageName = "config"
    if len(argv) > 1:
        if argv[1] == '--test':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            # Create GCP TLV database by importing the module
            from rpd.rcp.gcp.gcp_lib.testing import test_gcp_tlv_def
            database = test_gcp_tlv_def.Testing_GCP_TLV_SET
        elif argv[1] == '--gcp':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            from rpd.rcp.gcp.gcp_lib import gcp_tlv_def
            database = gcp_tlv_def.GCP_TLV_SET
        elif argv[1] == '--dpd':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            from rpd.rcp.rcp_lib import rcp_tlv_def

            database = rcp_tlv_def.DPD_TLV_SET
            messageName = "dpd"

        elif argv[1] == '--ocd':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            from rpd.rcp.rcp_lib import rcp_tlv_def
            database = rcp_tlv_def.OCD_TLV_SET
            messageName = "ocd"
        elif argv[1] == '--ucd':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            from rpd.rcp.rcp_lib import rcp_tlv_def
            database = rcp_tlv_def.UCD_TLV_SET
            messageName = "ucd"
        elif argv[1] == '--ucdBurst':
            next_arg += 1
            if len(argv) <= 2:
                print_help(argv)
                exit(1)
            from rpd.rcp.rcp_lib import rcp_tlv_def
            database = rcp_tlv_def.UCD_BURST_PROFILE_TLV_SET
            messageName = "burstProfile"
        else:
            from rpd.rcp.rcp_lib import rcp_tlv_def
            from rpd.rcp.vendorTLVs.src import vsp_tlv_def
            database = rcp_tlv_def.RCP_CFG_TLV_SET
    else:
        print_help(argv)
        exit(1)

    from rpd.rcp.gcp.gcp_lib.gcp_tlv_def import TLVDesc
    generator = ProtoGenerator(database, messageName)
    output_file = \
        argv[next_arg] if len(argv) > next_arg else generator.OUT_FILE
    generator.generate(output_file)
